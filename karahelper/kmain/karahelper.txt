Установка:
1. Файлы:
%Aegiroot%/automation/packages/karahelper.dll
%Aegiroot%/automation/include/karahelper.lua

Необходимо, чтобы в папочке %Aegiroot%/csri был хотя бы один csri-сервер. (для функции render)
2. В файле скрипта:
include("karahelper.lua")

Функции, предоставляемые плагином:
karahelper.text_extents(style,text)
Функция считает размер растеризованного текста в пикселях, а также возвращает некоторые свойства шрифта. (аналог aegisub.text_extents
Аргументы:
text - текст, который нужно превратить в растр
style - таблица стиля. (элементы массива styles, генерируемого karaskel.collect_head, line.kara[i].style, генерируемого karaskel.preproc_line)
в справке аеги еся: http://aegisub.cellosoft.com/docs/Automation_4_Lua_Miscellaneous_APIs
Возвращает таблицу со следующими полями:
width - ширина растеризованного текста
height - высота растеризованного текста
ascent - и т.д. (я нинаю, как это называется по-человечески)
descent
extlead
offsetx - на сколько сдвинута картинка вправо, чтоб вместилась левая часть текста (с окаёмкой, блюром и т.д.), учитывает окаёмку и теги \blur и \be
Поэтому координаты исходной точки на экране вычисляются просто:
	screenx = x - offsetx

Пример:
function do_fx(subs, meta, line)
	for i = 1, line.kara.n do
		local syl = line.kara[i]
		if(syl.duration>0)
			local te = karahelper.text_extents(syl.style,syl.text_stripped)
			local width = te.width
			local height = te.height
			-- вместо syl.width и syl.height, результаты немного различны
		end
	end
end

karahelper.text_outline(style,text)
Превращает текст, оформленный с помощью стиля style, в команды рисования (текст nya, Ариал, 50 размер):
m 0 24 l 0 1 4 1 4 4 b 6 2 8 0 11 0 b 12 0 13 0 14 1 b 15 1 16 2 17 3 b 17 4 18 5 18 6 b 18 7 18 8 18 10 l 18 24 14 24 14 10 b 14 9 14 7 14 7 b 13 6 13 5 12 5 b 11 4 11 4 10 4 b 8 4 7 5 6 6 b 5 7 4 9 4 12 l 4 24 m 24 33 l 23 29 b 24 29 25 29 25 29 b 26 29 27 29 27 29 b 28 28 28 28 28 27 b 29 27 29 26 30 25 b 30 24 30 24 30 24 l 21 1 25 1 30 13 b 31 15 32 17 32 18 b 33 17 33 16 33 14 l 38 1 42 1 34 25 b 33 27 32 29 32 30 b 31 31 30 32 30 32 b 29 33 28 33 26 33 b 26 33 25 33 24 33 m 59 21 b 58 22 57 23 55 23 b 54 24 53 24 51 24 b 49 24 47 24 46 22 b 45 21 44 20 44 18 b 44 16 44 15 45 15 b 45 14 46 13 47 12 b 47 12 48 11 49 11 b 50 11 51 11 52 10 b 55 10 58 10 59 9 b 59 9 59 8 59 8 b 59 7 59 6 58 5 b 57 4 56 4 54 4 b 53 4 51 4 51 5 b 50 6 49 7 49 8 l 45 7 b 45 6 46 4 47 3 b 47 2 48 1 50 1 b 51 0 53 0 55 0 b 57 0 58 0 59 1 b 60 1 61 2 62 3 b 62 3 63 4 63 5 b 63 6 63 7 63 9 l 63 14 b 63 17 63 19 63 20 b 63 22 64 23 64 24 l 60 24 b 60 23 59 22 59 21 m 59 13 b 58 14 56 14 53 14 b 52 14 51 15 50 15 b 49 15 49 15 49 16 b 48 16 48 17 48 17 b 48 18 48 19 49 19 b 50 20 51 20 52 20 b 54 20 55 20 56 19 b 57 19 58 18 58 17 b 59 16 59 15 59 14
В принципе, может пригодится для векторных клипов в виде текста. (накой о.О)
Учтите, за счет того, что только целочисленные значения координат используются, при уменьшении размера текста получим искажения. можно увеличить размер текста раз в 8 и уменьшить потом \fscx12.5 \fscy12.5

То есть, результат - строка.

Пример:
local txt = karahelper.text_outline(style,"nya")


karahelper.render(style,text)
Растеризует текст text, оформленный с помощью стиля style. Теги низя, за исключением \blur и \be.
Но в этом случае может быть только один блок с тегами: {\blur1}nya
Парсер берет только первую часть. если есть другие, то они игнорируются {\blur1}A{\be1}B превратится в {\blur1}A
Аргументы те же. Результаты те же.
Но вот что ещё, там добавляются две таблицы:
color[x][y]
alpha[x][y]
Координаты от 1 до width(height)

которые содержат, соответственно, цвет(RRGGBB) и прозрачность(AA) соответствующей точки.
И надо не забывать очищать память от этого массива, когда он больше не нужен.

Пример:
function do_fx(subs, meta, line)
	for i = 1, line.kara.n do
		local syl = line.kara[i]
		if(syl.duration>0)
			local render = karahelper.render(syl.style,syl.text_stripped)
			local dx = render.offsetx
			for x=1,render.width do
				for y=1,render.height do
					if(render.alpha[x][y]~=255)then -- not transparent
						local col = ass_dcolor(render.color[x][y])
						-- some code with it
						-- pixel is: "{\\p1}m 0 0 l 1 0 1 1 0 1{\\p0}"
						-- \pos(x-dx,y)
					end
				end
			end
			render = nil
		end
	end
end

karahelper.loadpng(filename)
Загружает картинку в формате png
поля:
width
height
color[x][y]
alpha[x][y]

всё то же самое